{
  "permissions": {
    "allow": [
      "Bash(pip3 list:*)",
      "Bash(python3:*)",
      "Bash(source venv/bin/activate)",
      "Bash(pip install:*)",
      "Bash(timeout 10 python:*)",
      "Bash(python:*)",
      "Bash(open http://localhost:5050)",
      "Bash(curl:*)",
      "mcp__filesystem__directory_tree",
      "mcp__filesystem__search_files",
      "mcp__filesystem__list_directory",
      "Bash(lsof:*)",
      "Bash(pkill:*)",
      "Bash(pgrep:*)",
      "Bash(xargs kill:*)",
      "Bash(./venv/bin/python -m pytest:*)",
      "Bash(./venv/bin/pip install:*)",
      "Bash(./venv/bin/python:*)",
      "Bash(ls:*)",
      "mcp__filesystem__read_text_file",
      "Bash(xargs rm:*)",
      "Bash(tee:*)",
      "Bash(kill:*)",
      "Bash(/Users/ubusan-nb-ecr/Documents/UpenderImp/CompleteCaso/venv/bin/python:*)",
      "Bash(wc:*)",
      "Bash(source:*)",
      "Bash(ps:*)",
      "Bash(sysctl:*)",
      "Bash(/Users/ubusan-nb-ecr/Documents/UpenderImp/CompleteCaso/scripts/hourly_monitor.sh << 'SCRIPT'\n#!/bin/bash\n# Hourly monitoring for marathon_v2\nOUTPUT=\"/Users/ubusan-nb-ecr/Documents/UpenderImp/CompleteCaso/scripts/marathon_v2_output.txt\"\nLOG=\"/Users/ubusan-nb-ecr/Documents/UpenderImp/CompleteCaso/scripts/hourly_updates.txt\"\n\necho \"========================================\" >> \"$LOG\"\necho \"HOURLY MONITORING STARTED: $\\(date\\)\" >> \"$LOG\"\necho \"========================================\" >> \"$LOG\"\n\nfor hour in $\\(seq 1 12\\); do\n    sleep 3600\n    echo \"\" >> \"$LOG\"\n    echo \"════════════════════════════════════════════════════════════════\" >> \"$LOG\"\n    echo \"HOUR $hour UPDATE — $\\(date\\)\" >> \"$LOG\"\n    echo \"════════════════════════════════════════════════════════════════\" >> \"$LOG\"\n    \n    # Check if process is alive\n    if ps aux | grep \"marathon_v2.py\" | grep -v grep > /dev/null 2>&1; then\n        CPU=$\\(ps aux | grep \"marathon_v2.py\" | grep -v grep | awk '{print $3}'\\)\n        echo \"  Process: RUNNING at ${CPU}% CPU\" >> \"$LOG\"\n    else\n        echo \"  Process: STOPPED\" >> \"$LOG\"\n    fi\n    \n    LINES=$\\(wc -l < \"$OUTPUT\"\\)\n    echo \"  Output lines: $LINES\" >> \"$LOG\"\n    \n    # Show phases reached\n    echo \"  Phases reached:\" >> \"$LOG\"\n    grep \"^PHASE\" \"$OUTPUT\" | while read line; do\n        echo \"    $line\" >> \"$LOG\"\n    done\n    \n    # Check for errors\n    ERRORS=$\\(grep -c \"Traceback\\\\|Error\" \"$OUTPUT\" 2>/dev/null || echo 0\\)\n    echo \"  Errors: $ERRORS\" >> \"$LOG\"\n    \n    # Show current leaderboard top 5 \\(last one printed\\)\n    echo \"  --- Latest Leaderboard Top 5 ---\" >> \"$LOG\"\n    # Get the last leaderboard block\n    grep -A 8 \"AFTER PHASE\" \"$OUTPUT\" | tail -15 >> \"$LOG\"\n    \n    echo \"  --- Last 5 lines of output ---\" >> \"$LOG\"\n    tail -5 \"$OUTPUT\" >> \"$LOG\"\n    \n    # If process died, note it\n    if ! ps aux | grep \"marathon_v2.py\" | grep -v grep > /dev/null 2>&1; then\n        echo \"\" >> \"$LOG\"\n        echo \"  *** MARATHON FINISHED OR CRASHED ***\" >> \"$LOG\"\n        echo \"  Check scripts/marathon_v2_output.txt for full results\" >> \"$LOG\"\n        break\n    fi\ndone\n\necho \"\" >> \"$LOG\"\necho \"════════════════════════════════════════════════════════════════\" >> \"$LOG\"\necho \"MONITORING COMPLETE — $\\(date\\)\" >> \"$LOG\"\necho \"════════════════════════════════════════════════════════════════\" >> \"$LOG\"\nSCRIPT)",
      "Bash(chmod:*)",
      "Bash(# Kill the slow V3 kill 53288 53287 echo \"\"Killed V3\"\" sleep 2 ps aux)",
      "Bash(numfmt:*)",
      "Bash(/Users/ubusan-nb-ecr/Documents/UpenderImp/CompleteCaso/model_testing/backtest_the_one.py << 'SCRIPT_EOF'\n#!/usr/bin/env python3\n\"\"\"\nBacktest: THE ONE Strategy on test_data1.txt \\(509 spins\\)\n=========================================================\nSimulates 60-spin sessions and a continuous rolling run using the actual\napp.ml.ensemble.EnsemblePredictor and app.money.bankroll_manager.BankrollManager.\n\nUsage:\n    cd /Users/ubusan-nb-ecr/Documents/UpenderImp/CompleteCaso\n    source venv/bin/activate\n    python model_testing/backtest_the_one.py\n\"\"\"\n\nimport sys\nimport os\nimport time\nimport statistics\nfrom collections import Counter, defaultdict\n\n# ── Project imports ──────────────────────────────────────────────────\nPROJECT_ROOT = '/Users/ubusan-nb-ecr/Documents/UpenderImp/CompleteCaso'\nsys.path.insert\\(0, PROJECT_ROOT\\)\n\ntry:\n    from app.ml.ensemble import EnsemblePredictor\n    from app.money.bankroll_manager import BankrollManager\n    from config import \\(\n        INITIAL_BANKROLL, CONFIDENCE_BET_THRESHOLD, STOP_LOSS_THRESHOLD,\n        TOP_PREDICTIONS_COUNT, BASE_BET, BET_SEQUENCE, PAYOUTS,\n        CONDITIONAL_BET_THRESHOLD\n    \\)\n    print\\(\"[OK] All project modules imported successfully.\"\\)\nexcept ImportError as e:\n    print\\(f\"[ERROR] Import failed: {e}\"\\)\n    print\\(\"Make sure you run from the project root with the venv activated.\"\\)\n    sys.exit\\(1\\)\n\n# ── Constants ────────────────────────────────────────────────────────\nDATA_FILE = os.path.join\\(PROJECT_ROOT, 'model_testing', 'test_data', 'test_data1.txt'\\)\nSESSION_LENGTH = 60\nWARMUP_SPINS = 10   # Feed data without betting for first N spins per session\n\n\ndef load_test_data\\(path\\):\n    \"\"\"Load spin numbers from text file \\(one number per line\\).\"\"\"\n    numbers = []\n    with open\\(path, 'r'\\) as f:\n        for line in f:\n            line = line.strip\\(\\)\n            if line and line.isdigit\\(\\):\n                num = int\\(line\\)\n                if 0 <= num <= 36:\n                    numbers.append\\(num\\)\n                else:\n                    print\\(f\"  [WARN] Skipping out-of-range number: {num}\"\\)\n    return numbers\n\n\ndef run_session\\(spins, session_id, verbose=False\\):\n    \"\"\"Run a single 60-spin session. Returns a stats dict.\"\"\"\n    ensemble = EnsemblePredictor\\(\\)\n    bankroll = BankrollManager\\(initial_bankroll=INITIAL_BANKROLL\\)\n\n    stats = {\n        'session_id': session_id,\n        'spins_processed': 0,\n        'bets_placed': 0,\n        'wins': 0,\n        'losses': 0,\n        'skips': 0,\n        'stop_loss_hit': False,\n        'total_wagered': 0.0,\n        'total_payouts': 0.0,\n        'start_bankroll': INITIAL_BANKROLL,\n        'end_bankroll': 0.0,\n        'profit_loss': 0.0,\n        'max_drawdown_pct': 0.0,\n        'max_drawdown_dollar': 0.0,\n        'peak_bankroll': INITIAL_BANKROLL,\n        'seq_steps_used': Counter\\(\\),\n        'confidences_bet': [],\n        'confidences_wait': [],\n        'hit_when_bet': 0,\n        'miss_when_bet': 0,\n        'hit_when_wait': 0,\n        'miss_when_wait': 0,\n        'wait_reasons': Counter\\(\\),\n    }\n\n    peak = INITIAL_BANKROLL\n\n    for i, actual_number in enumerate\\(spins\\):\n        stats['spins_processed'] += 1\n\n        # ── Warmup: feed data, no betting ──\n        if i < WARMUP_SPINS:\n            ensemble.update\\(actual_number\\)\n            bankroll.tick_wait\\(\\)\n            continue\n\n        # ── Get prediction ──\n        try:\n            prediction = ensemble.predict\\(\\)\n        except Exception as e:\n            if verbose:\n                print\\(f\"    Spin {i}: predict\\(\\) error: {e}\"\\)\n            ensemble.update\\(actual_number\\)\n            bankroll.tick_wait\\(\\)\n            stats['skips'] += 1\n            continue\n\n        top_numbers = prediction.get\\('top_numbers', []\\)\n        confidence = prediction.get\\('confidence', 0\\)\n        mode = prediction.get\\('mode', 'WAIT'\\)\n        should_bet_signal = prediction.get\\('should_bet', False\\)\n        num_predictions = len\\(top_numbers\\)\n\n        # ── Determine if we should bet ──\n        # Confidence gate from ensemble\n        ai_says_bet = \\(mode != 'WAIT' and confidence >= CONFIDENCE_BET_THRESHOLD\n                       and should_bet_signal\\)\n\n        # Bankroll manager gate\n        bm_should_bet, bm_reason = bankroll.should_bet\\(confidence, mode\\)\n\n        actually_bet = ai_says_bet and bm_should_bet\n\n        # Check if actual number is in predictions \\(for quality tracking\\)\n        hit = actual_number in top_numbers\n\n        if actually_bet and num_predictions > 0:\n            # ── Place bet ──\n            seq_step = bankroll.seq_idx\n            stats['seq_steps_used'][seq_step] += 1\n\n            per_number_bet = bankroll.calculate_bet_amount\\(\n                confidence, 'straight', num_predictions=num_predictions\n            \\)\n            total_bet = round\\(per_number_bet * num_predictions, 2\\)\n\n            stats['bets_placed'] += 1\n            stats['total_wagered'] += total_bet\n            stats['confidences_bet'].append\\(confidence\\)\n\n            if hit:\n                # WIN: payout is 35 × per_number_bet \\(the winning number's stake\\)\n                payout = 35 * per_number_bet\n                bankroll.process_result\\(total_bet, won=True, payout_amount=payout\\)\n                stats['wins'] += 1\n                stats['hit_when_bet'] += 1\n                stats['total_payouts'] += payout + per_number_bet  # 35:1 + stake back\n                if verbose:\n                    print\\(f\"    Spin {i}: BET step={seq_step} ${total_bet:.2f} on \"\n                          f\"{num_predictions} nums | HIT {actual_number} | \"\n                          f\"payout ${payout:.2f} | bankroll ${bankroll.bankroll:.2f}\"\\)\n            else:\n                # LOSS\n                bankroll.process_result\\(total_bet, won=False\\)\n                stats['losses'] += 1\n                stats['miss_when_bet'] += 1\n                if verbose:\n                    print\\(f\"    Spin {i}: BET step={seq_step} ${total_bet:.2f} on \"\n                          f\"{num_predictions} nums | MISS \\(actual={actual_number}\\) | \"\n                          f\"bankroll ${bankroll.bankroll:.2f}\"\\)\n        else:\n            # ── Skip / Wait ──\n            stats['skips'] += 1\n            if not ai_says_bet:\n                reason = f\"AI:{mode}/conf={confidence:.0f}\"\n            else:\n                reason = bm_reason\n            stats['wait_reasons'][reason] += 1\n            stats['confidences_wait'].append\\(confidence\\)\n            if hit:\n                stats['hit_when_wait'] += 1\n            else:\n                stats['miss_when_wait'] += 1\n\n        # Tick bankroll cooldowns\n        if not actually_bet:\n            bankroll.tick_wait\\(\\)\n\n        # ── Feed actual result to ensemble ──\n        ensemble.update\\(actual_number\\)\n\n        # Track peak and drawdown\n        if bankroll.bankroll > peak:\n            peak = bankroll.bankroll\n        dd_dollar = peak - bankroll.bankroll\n        dd_pct = \\(dd_dollar / peak * 100\\) if peak > 0 else 0\n        if dd_dollar > stats['max_drawdown_dollar']:\n            stats['max_drawdown_dollar'] = dd_dollar\n            stats['max_drawdown_pct'] = dd_pct\n\n        # ── Stop-loss check ──\n        if bankroll.stop_loss_hit:\n            stats['stop_loss_hit'] = True\n            if verbose:\n                print\\(f\"    *** STOP-LOSS HIT at spin {i} | bankroll ${bankroll.bankroll:.2f}\"\\)\n            break\n\n    stats['end_bankroll'] = round\\(bankroll.bankroll, 2\\)\n    stats['profit_loss'] = round\\(bankroll.bankroll - INITIAL_BANKROLL, 2\\)\n    stats['peak_bankroll'] = round\\(peak, 2\\)\n\n    return stats\n\n\ndef run_all_sessions\\(all_spins\\):\n    \"\"\"Run multiple independent 60-spin sessions across the data.\"\"\"\n    sessions = []\n    total_spins = len\\(all_spins\\)\n    idx = 0\n    session_id = 1\n\n    print\\(f\"\\\\n{'='*70}\"\\)\n    print\\(f\"  INDEPENDENT SESSION MODE  \\({SESSION_LENGTH}-spin sessions\\)\"\\)\n    print\\(f\"{'='*70}\"\\)\n    print\\(f\"  Total spins available: {total_spins}\"\\)\n    print\\(f\"  Sessions possible: {total_spins // SESSION_LENGTH}\"\\)\n    print\\(f\"  Warmup spins per session: {WARMUP_SPINS}\"\\)\n    print\\(f\"  Initial bankroll: ${INITIAL_BANKROLL:,.2f}\"\\)\n    print\\(f\"  Stop-loss: ${STOP_LOSS_THRESHOLD:,.2f}\"\\)\n    print\\(f\"  Confidence gate: {CONFIDENCE_BET_THRESHOLD}%\"\\)\n    print\\(f\"  Bet sequence: {list\\(BET_SEQUENCE\\)} x ${BASE_BET}\"\\)\n    print\\(f\"{'='*70}\\\\n\"\\)\n\n    while idx + SESSION_LENGTH <= total_spins:\n        session_spins = all_spins[idx:idx + SESSION_LENGTH]\n        t0 = time.time\\(\\)\n        stats = run_session\\(session_spins, session_id, verbose=False\\)\n        elapsed = time.time\\(\\) - t0\n\n        pl_str = f\"+${stats['profit_loss']:.2f}\" if stats['profit_loss'] >= 0 else f\"-${abs\\(stats['profit_loss']\\):.2f}\"\n        hit_rate = \\(stats['wins'] / stats['bets_placed'] * 100\\) if stats['bets_placed'] > 0 else 0\n        stop_str = \" [STOP-LOSS]\" if stats['stop_loss_hit'] else \"\"\n\n        print\\(f\"  Session {session_id:2d} | spins {idx+1:3d}-{idx+SESSION_LENGTH:3d} | \"\n              f\"P/L: {pl_str:>10s} | bets: {stats['bets_placed']:2d} | \"\n              f\"W/L: {stats['wins']}/{stats['losses']} | \"\n              f\"hit: {hit_rate:5.1f}% | \"\n              f\"dd: ${stats['max_drawdown_dollar']:.0f} | \"\n              f\"{elapsed:.1f}s{stop_str}\"\\)\n\n        sessions.append\\(stats\\)\n        idx += SESSION_LENGTH\n        session_id += 1\n\n    # Handle remaining spins \\(partial session\\)\n    if idx < total_spins:\n        remaining = total_spins - idx\n        session_spins = all_spins[idx:]\n        t0 = time.time\\(\\)\n        stats = run_session\\(session_spins, session_id, verbose=False\\)\n        elapsed = time.time\\(\\) - t0\n\n        pl_str = f\"+${stats['profit_loss']:.2f}\" if stats['profit_loss'] >= 0 else f\"-${abs\\(stats['profit_loss']\\):.2f}\"\n        hit_rate = \\(stats['wins'] / stats['bets_placed'] * 100\\) if stats['bets_placed'] > 0 else 0\n        stop_str = \" [STOP-LOSS]\" if stats['stop_loss_hit'] else \"\"\n\n        print\\(f\"  Session {session_id:2d} | spins {idx+1:3d}-{total_spins:3d} \\({remaining} spins\\) | \"\n              f\"P/L: {pl_str:>10s} | bets: {stats['bets_placed']:2d} | \"\n              f\"W/L: {stats['wins']}/{stats['losses']} | \"\n              f\"hit: {hit_rate:5.1f}% | \"\n              f\"dd: ${stats['max_drawdown_dollar']:.0f} | \"\n              f\"{elapsed:.1f}s{stop_str}\"\\)\n        sessions.append\\(stats\\)\n\n    return sessions\n\n\ndef run_rolling\\(all_spins\\):\n    \"\"\"Run a single continuous session across ALL spins, reporting every 60.\"\"\"\n    print\\(f\"\\\\n{'='*70}\"\\)\n    print\\(f\"  ROLLING \\(CONTINUOUS\\) MODE  — single ensemble across all {len\\(all_spins\\)} spins\"\\)\n    print\\(f\"{'='*70}\\\\n\"\\)\n\n    ensemble = EnsemblePredictor\\(\\)\n    bankroll = BankrollManager\\(initial_bankroll=INITIAL_BANKROLL\\)\n\n    # Aggregate stats\n    total_bets = 0\n    total_wins = 0\n    total_losses = 0\n    total_skips = 0\n    total_wagered = 0.0\n    total_payouts = 0.0\n    confidences_bet = []\n    confidences_wait = []\n    hit_when_bet = 0\n    miss_when_bet = 0\n    hit_when_wait = 0\n    miss_when_wait = 0\n    seq_steps_used = Counter\\(\\)\n    peak = INITIAL_BANKROLL\n    max_dd_dollar = 0\n    max_dd_pct = 0\n    segment_start_bankroll = INITIAL_BANKROLL\n    stop_loss_hit = False\n\n    # Segment reporting\n    segment_results = []\n\n    t0 = time.time\\(\\)\n    for i, actual_number in enumerate\\(all_spins\\):\n        # Warmup for the first N spins\n        if i < WARMUP_SPINS:\n            ensemble.update\\(actual_number\\)\n            bankroll.tick_wait\\(\\)\n            continue\n\n        # Predict\n        try:\n            prediction = ensemble.predict\\(\\)\n        except Exception as e:\n            ensemble.update\\(actual_number\\)\n            bankroll.tick_wait\\(\\)\n            total_skips += 1\n            continue\n\n        top_numbers = prediction.get\\('top_numbers', []\\)\n        confidence = prediction.get\\('confidence', 0\\)\n        mode = prediction.get\\('mode', 'WAIT'\\)\n        should_bet_signal = prediction.get\\('should_bet', False\\)\n        num_predictions = len\\(top_numbers\\)\n\n        ai_says_bet = \\(mode != 'WAIT' and confidence >= CONFIDENCE_BET_THRESHOLD\n                       and should_bet_signal\\)\n        bm_should_bet, bm_reason = bankroll.should_bet\\(confidence, mode\\)\n        actually_bet = ai_says_bet and bm_should_bet\n\n        hit = actual_number in top_numbers\n\n        if actually_bet and num_predictions > 0:\n            seq_step = bankroll.seq_idx\n            seq_steps_used[seq_step] += 1\n\n            per_number_bet = bankroll.calculate_bet_amount\\(\n                confidence, 'straight', num_predictions=num_predictions\n            \\)\n            total_bet_amt = round\\(per_number_bet * num_predictions, 2\\)\n\n            total_bets += 1\n            total_wagered += total_bet_amt\n            confidences_bet.append\\(confidence\\)\n\n            if hit:\n                payout = 35 * per_number_bet\n                bankroll.process_result\\(total_bet_amt, won=True, payout_amount=payout\\)\n                total_wins += 1\n                hit_when_bet += 1\n                total_payouts += payout + per_number_bet\n            else:\n                bankroll.process_result\\(total_bet_amt, won=False\\)\n                total_losses += 1\n                miss_when_bet += 1\n        else:\n            total_skips += 1\n            confidences_wait.append\\(confidence\\)\n            if hit:\n                hit_when_wait += 1\n            else:\n                miss_when_wait += 1\n            bankroll.tick_wait\\(\\)\n\n        ensemble.update\\(actual_number\\)\n\n        # Track peak/drawdown\n        if bankroll.bankroll > peak:\n            peak = bankroll.bankroll\n        dd_d = peak - bankroll.bankroll\n        dd_p = \\(dd_d / peak * 100\\) if peak > 0 else 0\n        if dd_d > max_dd_dollar:\n            max_dd_dollar = dd_d\n            max_dd_pct = dd_p\n\n        # Segment report every SESSION_LENGTH spins\n        if \\(i + 1\\) % SESSION_LENGTH == 0 or i == len\\(all_spins\\) - 1:\n            seg_pl = bankroll.bankroll - segment_start_bankroll\n            seg_num = \\(i + 1\\) // SESSION_LENGTH\n            pl_str = f\"+${seg_pl:.2f}\" if seg_pl >= 0 else f\"-${abs\\(seg_pl\\):.2f}\"\n            cumul = bankroll.bankroll - INITIAL_BANKROLL\n            cumul_str = f\"+${cumul:.2f}\" if cumul >= 0 else f\"-${abs\\(cumul\\):.2f}\"\n            print\\(f\"  Spins {max\\(1,i+2-SESSION_LENGTH\\):3d}-{i+1:3d} | \"\n                  f\"segment P/L: {pl_str:>10s} | \"\n                  f\"cumulative: {cumul_str:>10s} | \"\n                  f\"bankroll: ${bankroll.bankroll:,.2f}\"\\)\n            segment_results.append\\({\n                'segment': seg_num,\n                'segment_pl': seg_pl,\n                'cumulative_pl': cumul,\n                'bankroll': bankroll.bankroll,\n            }\\)\n            segment_start_bankroll = bankroll.bankroll\n\n        # Stop-loss\n        if bankroll.stop_loss_hit:\n            stop_loss_hit = True\n            print\\(f\"\\\\n  *** STOP-LOSS HIT at spin {i+1} | bankroll ${bankroll.bankroll:.2f}\"\\)\n            break\n\n    elapsed = time.time\\(\\) - t0\n\n    rolling_stats = {\n        'total_spins': len\\(all_spins\\),\n        'spins_processed': min\\(i + 1, len\\(all_spins\\)\\),\n        'total_bets': total_bets,\n        'total_wins': total_wins,\n        'total_losses': total_losses,\n        'total_skips': total_skips,\n        'total_wagered': total_wagered,\n        'total_payouts': total_payouts,\n        'start_bankroll': INITIAL_BANKROLL,\n        'end_bankroll': bankroll.bankroll,\n        'profit_loss': bankroll.bankroll - INITIAL_BANKROLL,\n        'peak_bankroll': peak,\n        'max_drawdown_dollar': max_dd_dollar,\n        'max_drawdown_pct': max_dd_pct,\n        'stop_loss_hit': stop_loss_hit,\n        'confidences_bet': confidences_bet,\n        'confidences_wait': confidences_wait,\n        'hit_when_bet': hit_when_bet,\n        'miss_when_bet': miss_when_bet,\n        'hit_when_wait': hit_when_wait,\n        'miss_when_wait': miss_when_wait,\n        'seq_steps_used': seq_steps_used,\n        'elapsed': elapsed,\n        'segments': segment_results,\n    }\n    return rolling_stats\n\n\ndef print_session_analytics\\(sessions\\):\n    \"\"\"Print comprehensive session-based analytics.\"\"\"\n    n = len\\(sessions\\)\n    if n == 0:\n        print\\(\"  No sessions to analyze.\"\\)\n        return\n\n    pls = [s['profit_loss'] for s in sessions]\n    profitable = [p for p in pls if p > 0]\n    losing = [p for p in pls if p < 0]\n    breakeven = [p for p in pls if p == 0]\n    bets_per_session = [s['bets_placed'] for s in sessions]\n    hit_rates = [\\(s['wins'] / s['bets_placed'] * 100\\) if s['bets_placed'] > 0 else 0\n                 for s in sessions]\n    stop_losses = sum\\(1 for s in sessions if s['stop_loss_hit']\\)\n\n    # Aggregate sequence steps\n    all_seq_steps = Counter\\(\\)\n    for s in sessions:\n        all_seq_steps.update\\(s['seq_steps_used']\\)\n\n    # Aggregate confidences\n    all_conf_bet = []\n    all_conf_wait = []\n    for s in sessions:\n        all_conf_bet.extend\\(s['confidences_bet']\\)\n        all_conf_wait.extend\\(s['confidences_wait']\\)\n\n    # Financial aggregates\n    total_wagered = sum\\(s['total_wagered'] for s in sessions\\)\n    total_payouts = sum\\(s['total_payouts'] for s in sessions\\)\n    total_bets_count = sum\\(s['bets_placed'] for s in sessions\\)\n    total_wins = sum\\(s['wins'] for s in sessions\\)\n    total_losses_count = sum\\(s['losses'] for s in sessions\\)\n    total_skips = sum\\(s['skips'] for s in sessions\\)\n    total_spins = sum\\(s['spins_processed'] for s in sessions\\)\n    total_pl = sum\\(pls\\)\n\n    # Prediction quality aggregates\n    hit_bet_all = sum\\(s['hit_when_bet'] for s in sessions\\)\n    miss_bet_all = sum\\(s['miss_when_bet'] for s in sessions\\)\n    hit_wait_all = sum\\(s['hit_when_wait'] for s in sessions\\)\n    miss_wait_all = sum\\(s['miss_when_wait'] for s in sessions\\)\n\n    # ── SESSION ANALYTICS ──\n    print\\(f\"\\\\n{'='*70}\"\\)\n    print\\(f\"  SESSION ANALYTICS\"\\)\n    print\\(f\"{'='*70}\"\\)\n    print\\(f\"  Total sessions played:       {n}\"\\)\n    print\\(f\"  Profitable sessions:         {len\\(profitable\\)} \\({len\\(profitable\\)/n*100:.1f}%\\)\"\\)\n    print\\(f\"  Losing sessions:             {len\\(losing\\)} \\({len\\(losing\\)/n*100:.1f}%\\)\"\\)\n    print\\(f\"  Break-even sessions:         {len\\(breakeven\\)} \\({len\\(breakeven\\)/n*100:.1f}%\\)\"\\)\n    print\\(f\"  Average P/L per session:     ${statistics.mean\\(pls\\):+.2f}\"\\)\n    print\\(f\"  Median session result:       ${statistics.median\\(pls\\):+.2f}\"\\)\n    print\\(f\"  Best session profit:         ${max\\(pls\\):+.2f}\"\\)\n    print\\(f\"  Worst session loss:          ${min\\(pls\\):+.2f}\"\\)\n    print\\(f\"  Std dev of session P/L:      ${statistics.stdev\\(pls\\):.2f}\" if n > 1 else \"\"\\)\n    print\\(f\"  Total P/L across all:        ${total_pl:+.2f}\"\\)\n    print\\(f\"  Avg bets placed / session:   {statistics.mean\\(bets_per_session\\):.1f}\"\\)\n    print\\(f\"  Avg hit rate / session:      {statistics.mean\\(hit_rates\\):.1f}%\"\\)\n    print\\(f\"  Stop-loss hit count:         {stop_losses} \\({stop_losses/n*100:.1f}%\\)\"\\)\n\n    # ── BETTING ANALYTICS ──\n    print\\(f\"\\\\n{'='*70}\"\\)\n    print\\(f\"  BETTING ANALYTICS\"\\)\n    print\\(f\"{'='*70}\"\\)\n    print\\(f\"  Total spins processed:       {total_spins}\"\\)\n    print\\(f\"  Total bets placed:           {total_bets_count}\"\\)\n    print\\(f\"  Total skips \\(WAIT\\):          {total_skips}\"\\)\n    bet_freq = \\(total_bets_count / total_spins * 100\\) if total_spins > 0 else 0\n    print\\(f\"  Bet frequency:               {bet_freq:.1f}% of spins\"\\)\n    print\\(f\"  Total wins:                  {total_wins}\"\\)\n    print\\(f\"  Total losses:                {total_losses_count}\"\\)\n    wr = \\(total_wins / total_bets_count * 100\\) if total_bets_count > 0 else 0\n    print\\(f\"  Overall win rate:            {wr:.1f}%\"\\)\n    avg_conf_bet = statistics.mean\\(all_conf_bet\\) if all_conf_bet else 0\n    avg_conf_wait = statistics.mean\\(all_conf_wait\\) if all_conf_wait else 0\n    print\\(f\"  Avg confidence when betting: {avg_conf_bet:.1f}%\"\\)\n    print\\(f\"  Avg confidence when waiting: {avg_conf_wait:.1f}%\"\\)\n\n    print\\(f\"\\\\n  Sequence step distribution:\"\\)\n    for step in sorted\\(all_seq_steps.keys\\(\\)\\):\n        mult = BET_SEQUENCE[step] if step < len\\(BET_SEQUENCE\\) else '?'\n        count = all_seq_steps[step]\n        pct = count / total_bets_count * 100 if total_bets_count > 0 else 0\n        print\\(f\"    Step {step} \\(x{mult}\\): {count:3d} bets \\({pct:.1f}%\\)\"\\)\n\n    # ── FINANCIAL ANALYTICS ──\n    print\\(f\"\\\\n{'='*70}\"\\)\n    print\\(f\"  FINANCIAL ANALYTICS\"\\)\n    print\\(f\"{'='*70}\"\\)\n    print\\(f\"  Total money wagered:         ${total_wagered:,.2f}\"\\)\n    print\\(f\"  Total payouts received:      ${total_payouts:,.2f}\"\\)\n    print\\(f\"  Net profit/loss:             ${total_pl:+,.2f}\"\\)\n    roi = \\(total_pl / total_wagered * 100\\) if total_wagered > 0 else 0\n    print\\(f\"  ROI \\(net / wagered\\):         {roi:+.2f}%\"\\)\n    avg_bet = total_wagered / total_bets_count if total_bets_count > 0 else 0\n    print\\(f\"  Average total bet size:      ${avg_bet:.2f} \\(across {TOP_PREDICTIONS_COUNT} numbers\\)\"\\)\n    avg_per_num = avg_bet / TOP_PREDICTIONS_COUNT if TOP_PREDICTIONS_COUNT > 0 else 0\n    print\\(f\"  Average per-number bet:      ${avg_per_num:.2f}\"\\)\n\n    # Max drawdown across sessions\n    max_dd = max\\(s['max_drawdown_dollar'] for s in sessions\\)\n    max_dd_pct = max\\(s['max_drawdown_pct'] for s in sessions\\)\n    print\\(f\"  Worst session drawdown:      ${max_dd:,.2f} \\({max_dd_pct:.1f}%\\)\"\\)\n\n    # ── PREDICTION QUALITY ──\n    print\\(f\"\\\\n{'='*70}\"\\)\n    print\\(f\"  PREDICTION QUALITY\"\\)\n    print\\(f\"{'='*70}\"\\)\n    total_predictions = hit_bet_all + miss_bet_all + hit_wait_all + miss_wait_all\n    total_hits = hit_bet_all + hit_wait_all\n    overall_hit = \\(total_hits / total_predictions * 100\\) if total_predictions > 0 else 0\n    print\\(f\"  Total predictions evaluated: {total_predictions}\"\\)\n    print\\(f\"  Overall hit rate:            {overall_hit:.1f}% \\({total_hits}/{total_predictions}\\)\"\\)\n\n    bet_preds = hit_bet_all + miss_bet_all\n    hit_rate_bet = \\(hit_bet_all / bet_preds * 100\\) if bet_preds > 0 else 0\n    print\\(f\"  Hit rate when BETTING:       {hit_rate_bet:.1f}% \\({hit_bet_all}/{bet_preds}\\)\"\\)\n\n    wait_preds = hit_wait_all + miss_wait_all\n    hit_rate_wait = \\(hit_wait_all / wait_preds * 100\\) if wait_preds > 0 else 0\n    print\\(f\"  Hit rate when WAITING:       {hit_rate_wait:.1f}% \\({hit_wait_all}/{wait_preds}\\)\"\\)\n\n    # Theoretical random hit rate for reference\n    theoretical = TOP_PREDICTIONS_COUNT / 37 * 100\n    print\\(f\"  Theoretical random hit rate: {theoretical:.1f}% \\({TOP_PREDICTIONS_COUNT}/37\\)\"\\)\n    edge = overall_hit - theoretical\n    print\\(f\"  Edge over random:            {edge:+.1f}%\"\\)\n\n    # Confidence calibration\n    print\\(f\"\\\\n  Confidence calibration:\"\\)\n    if all_conf_bet:\n        # Bin by confidence ranges\n        bins = [\\(65, 70\\), \\(70, 75\\), \\(75, 80\\), \\(80, 85\\), \\(85, 90\\), \\(90, 100\\)]\n        # Collect per-session data into per-bin\n        all_bet_conf_hit = list\\(zip\\(all_conf_bet,\n                                     [True]*hit_bet_all + [False]*miss_bet_all\\)\\)\n        # Actually we need matched pairs. Let me collect them properly from sessions.\n        # Since we don't have matched pairs in aggregate, report average confidence vs actual hit rate\n        print\\(f\"    Avg reported confidence:   {avg_conf_bet:.1f}%\"\\)\n        print\\(f\"    Actual hit rate at bet:    {hit_rate_bet:.1f}%\"\\)\n        if avg_conf_bet > 0:\n            calibration = hit_rate_bet / avg_conf_bet * 100\n            print\\(f\"    Calibration ratio:         {calibration:.1f}% \\(100% = perfectly calibrated\\)\"\\)\n\n\ndef print_rolling_analytics\\(stats\\):\n    \"\"\"Print rolling/continuous session analytics.\"\"\"\n    print\\(f\"\\\\n{'='*70}\"\\)\n    print\\(f\"  ROLLING SESSION ANALYTICS\"\\)\n    print\\(f\"{'='*70}\"\\)\n    print\\(f\"  Total spins:                 {stats['spins_processed']}\"\\)\n    print\\(f\"  Total bets placed:           {stats['total_bets']}\"\\)\n    print\\(f\"  Total skips:                 {stats['total_skips']}\"\\)\n    bet_freq = \\(stats['total_bets'] / stats['spins_processed'] * 100\\) if stats['spins_processed'] > 0 else 0\n    print\\(f\"  Bet frequency:               {bet_freq:.1f}%\"\\)\n    print\\(f\"  Wins / Losses:               {stats['total_wins']} / {stats['total_losses']}\"\\)\n    wr = \\(stats['total_wins'] / stats['total_bets'] * 100\\) if stats['total_bets'] > 0 else 0\n    print\\(f\"  Win rate:                    {wr:.1f}%\"\\)\n    print\\(f\"  \"\\)\n    print\\(f\"  Start bankroll:              ${stats['start_bankroll']:,.2f}\"\\)\n    print\\(f\"  End bankroll:                ${stats['end_bankroll']:,.2f}\"\\)\n    pl = stats['profit_loss']\n    print\\(f\"  Net profit/loss:             ${pl:+,.2f}\"\\)\n    print\\(f\"  Peak bankroll:               ${stats['peak_bankroll']:,.2f}\"\\)\n    print\\(f\"  Max drawdown:                ${stats['max_drawdown_dollar']:,.2f} \\({stats['max_drawdown_pct']:.1f}%\\)\"\\)\n    print\\(f\"  Stop-loss hit:               {'YES' if stats['stop_loss_hit'] else 'No'}\"\\)\n    print\\(f\"  Total wagered:               ${stats['total_wagered']:,.2f}\"\\)\n    print\\(f\"  Total payouts:               ${stats['total_payouts']:,.2f}\"\\)\n    roi = \\(pl / stats['total_wagered'] * 100\\) if stats['total_wagered'] > 0 else 0\n    print\\(f\"  ROI:                         {roi:+.2f}%\"\\)\n    print\\(f\"  Elapsed time:                {stats['elapsed']:.1f}s\"\\)\n\n    # Prediction quality\n    total_preds = \\(stats['hit_when_bet'] + stats['miss_when_bet'] +\n                   stats['hit_when_wait'] + stats['miss_when_wait']\\)\n    total_hits = stats['hit_when_bet'] + stats['hit_when_wait']\n    overall_hit = \\(total_hits / total_preds * 100\\) if total_preds > 0 else 0\n    bet_preds = stats['hit_when_bet'] + stats['miss_when_bet']\n    hit_rate_bet = \\(stats['hit_when_bet'] / bet_preds * 100\\) if bet_preds > 0 else 0\n    wait_preds = stats['hit_when_wait'] + stats['miss_when_wait']\n    hit_rate_wait = \\(stats['hit_when_wait'] / wait_preds * 100\\) if wait_preds > 0 else 0\n\n    print\\(f\"\\\\n  Prediction quality:\"\\)\n    print\\(f\"    Overall hit rate:          {overall_hit:.1f}% \\({total_hits}/{total_preds}\\)\"\\)\n    print\\(f\"    Hit rate when BETTING:     {hit_rate_bet:.1f}% \\({stats['hit_when_bet']}/{bet_preds}\\)\"\\)\n    print\\(f\"    Hit rate when WAITING:     {hit_rate_wait:.1f}% \\({stats['hit_when_wait']}/{wait_preds}\\)\"\\)\n\n    if stats['confidences_bet']:\n        avg_cb = statistics.mean\\(stats['confidences_bet']\\)\n        print\\(f\"    Avg confidence at bet:     {avg_cb:.1f}%\"\\)\n    if stats['confidences_wait']:\n        avg_cw = statistics.mean\\(stats['confidences_wait']\\)\n        print\\(f\"    Avg confidence at wait:    {avg_cw:.1f}%\"\\)\n\n    # Sequence steps\n    if stats['seq_steps_used']:\n        print\\(f\"\\\\n  Sequence step distribution:\"\\)\n        for step in sorted\\(stats['seq_steps_used'].keys\\(\\)\\):\n            mult = BET_SEQUENCE[step] if step < len\\(BET_SEQUENCE\\) else '?'\n            count = stats['seq_steps_used'][step]\n            pct = count / stats['total_bets'] * 100 if stats['total_bets'] > 0 else 0\n            print\\(f\"    Step {step} \\(x{mult}\\): {count:3d} bets \\({pct:.1f}%\\)\"\\)\n\n\n# ── MAIN ─────────────────────────────────────────────────────────────\ndef main\\(\\):\n    print\\(f\"\\\\n{'#'*70}\"\\)\n    print\\(f\"  BACKTEST: THE ONE STRATEGY\"\\)\n    print\\(f\"  Data: {DATA_FILE}\"\\)\n    print\\(f\"{'#'*70}\"\\)\n\n    # Load data\n    all_spins = load_test_data\\(DATA_FILE\\)\n    print\\(f\"\\\\n  Loaded {len\\(all_spins\\)} spin numbers.\"\\)\n    print\\(f\"  Number distribution: min={min\\(all_spins\\)}, max={max\\(all_spins\\)}, \"\n          f\"unique={len\\(set\\(all_spins\\)\\)}\"\\)\n\n    # Quick distribution check\n    freq = Counter\\(all_spins\\)\n    most_common = freq.most_common\\(5\\)\n    least_common = freq.most_common\\(\\)[-5:]\n    print\\(f\"  Most frequent:  {[\\(n, c\\) for n, c in most_common]}\"\\)\n    print\\(f\"  Least frequent: {[\\(n, c\\) for n, c in least_common]}\"\\)\n\n    # ── Part 1: Independent Sessions ──\n    t_start = time.time\\(\\)\n    sessions = run_all_sessions\\(all_spins\\)\n    t_sessions = time.time\\(\\) - t_start\n\n    print_session_analytics\\(sessions\\)\n    print\\(f\"\\\\n  [Sessions completed in {t_sessions:.1f}s]\"\\)\n\n    # ── Part 2: Rolling \\(Continuous\\) ──\n    t_start = time.time\\(\\)\n    rolling = run_rolling\\(all_spins\\)\n    t_rolling = time.time\\(\\) - t_start\n\n    print_rolling_analytics\\(rolling\\)\n    print\\(f\"\\\\n  [Rolling completed in {t_rolling:.1f}s]\"\\)\n\n    # ── Final Summary ──\n    print\\(f\"\\\\n{'#'*70}\"\\)\n    print\\(f\"  FINAL COMPARISON\"\\)\n    print\\(f\"{'#'*70}\"\\)\n    session_pl = sum\\(s['profit_loss'] for s in sessions\\)\n    rolling_pl = rolling['profit_loss']\n    print\\(f\"  Independent sessions total P/L:  ${session_pl:+,.2f}\"\\)\n    print\\(f\"  Rolling continuous P/L:          ${rolling_pl:+,.2f}\"\\)\n\n    session_bets = sum\\(s['bets_placed'] for s in sessions\\)\n    session_wins = sum\\(s['wins'] for s in sessions\\)\n    swr = \\(session_wins / session_bets * 100\\) if session_bets > 0 else 0\n    rwr = \\(rolling['total_wins'] / rolling['total_bets'] * 100\\) if rolling['total_bets'] > 0 else 0\n    print\\(f\"  Session win rate:                {swr:.1f}% \\({session_wins}/{session_bets}\\)\"\\)\n    print\\(f\"  Rolling win rate:                {rwr:.1f}% \\({rolling['total_wins']}/{rolling['total_bets']}\\)\"\\)\n    print\\(f\"{'#'*70}\\\\n\"\\)\n\n\nif __name__ == '__main__':\n    main\\(\\)\nSCRIPT_EOF)"
    ]
  }
}
